"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const wsExporter_1 = require("./wsExporter");
const MarkdownIt = require("markdown-it");
const md = new MarkdownIt();
const PREAMBLE = `
\\documentclass[a4paper]{article},
\\usepackage{geometry},
\\geometry{a4paper, total={170mm,257mm}, left=20mm, top=20mm},
\\usepackage{tasks},
\\usepackage[utf8]{inputenc},
\\usepackage[T1]{fontenc},
\\usepackage{enumitem},
\\usepackage{amsmath},
\\usepackage{eurosym},  
\\usepackage{xcolor},
\\definecolor{BLAUCLAR}{RGB}{240,240,255},
\\definecolor{MORAT}{RGB}{240,230,255}\\n",
\\begin{document},      
`;
function wsExporterLatex(adt, opts) {
    const builder = ["# Generated by wsMath on " + new Date() + " (c) J. Mulet (2018)", PREAMBLE];
    if (adt.title) {
        builder.push("\\begin{center}\\large \\textbf{ \\color{blue} " + adt.title + "} \\end{center}\n\\vspace{0.5cm}\n");
    }
    if (adt.instructions) {
        builder.push("\\fcolorbox{blue}{BLAUCLAR}{ \\parbox{0.93\\textwidth}{" + adt.instructions + "}}\n\\vspace{0.5cm}\n");
    }
    builder.push(`\n {\\small \\textbf{${wsExporter_1.i18n('REFERENCE', opts.lang)}}   ${adt.sid}  /  ${adt.seed} .} \\textbf{${wsExporter_1.i18n('NAME', opts.lang)}:}  
        ${adt.fullname ? adt.fullname : ''}  \\dotfill`);
    if (adt.activities) {
        builder.push("\\begin{enumerate}");
        adt.activities.forEach((activity) => {
            builder.push(...renderActivity(activity, opts));
        });
        builder.push("\\end{enumerate}");
    }
    if (adt.sections) {
        adt.sections.forEach((section) => {
            builder.push("  \\section{" + section.title + "}");
            builder.push("      \\begin{enumerate}[resume]");
            section.activities.forEach((activity) => {
                builder.push(...renderActivity(activity, opts));
            });
            builder.push("     \\end{enumerate}\n");
        });
    }
    if (opts.includeKeys !== 0 && !opts.keysPlacement) {
        builder.push(`  \\section*{${wsExporter_1.i18n('ANSWERS', opts.lang)}}`);
        builder.push("  \\begin{enumerate}");
        if (adt.activities) {
            adt.activities.forEach(activity => builder.push(...renderActivityAnswer(activity, opts)));
        }
        if (adt.sections) {
            adt.sections.forEach((section) => {
                section.activities.forEach(activity => {
                    builder.push(...renderActivityAnswer(activity, opts));
                });
            });
        }
        builder.push("  \\end{enumerate}");
    }
    builder.push("\\end{document}\n");
    return filterLatex(builder.join("\n"));
}
exports.wsExporterLatex = wsExporterLatex;
function removeLaTeXCmds(cmd) {
    const filtered = (cmd || "").replace(/\s/g, "").replace(/\\/gm, "").replace(/\{/gm, "").replace(/\}/gm, "")
        .replace(/dfrac/gmi, "").replace(/frac/gmi, "").replace(/sqrt/gmi, "").replace(/cdot/gmi, ".")
        .replace(/beginarray/gmi, " ").replace(/endarray/gmi, " ")
        .replace(/left/gmi, "").replace(/right/gmi, "")
        .replace(/\^/gmi, "").replace(/\_/gmi, "");
    return filtered;
}
function renderActivity(activity, opts) {
    const latex = [];
    activity.formulation = markdownToLatex(activity.formulation);
    if (activity.questions.length === 0) {
        // Assume that this is a theory box
        latex.push("\\par \\noindent \\vspace{0.25cm} \\fcolorbox{purple}{MORAT}{ \\parbox{0.88\\textwidth}{" +
            activity.formulation + "}}\n\\vspace{0.25cm}\n\n");
    }
    else if (activity.questions.length === 1) {
        activity.questions.forEach((question) => {
            latex.push("    \\item " + activity.formulation + markdownToLatex(question.formulation));
        });
    }
    else {
        latex.push("    \\item " + activity.formulation);
        // Try to guess the number of columns
        const lengths = this.questions.map(question => removeLaTeXCmds(question.formulation).length);
        const maxLength = Math.max(...lengths);
        const cols = maxLength < 26 ? 2 : 1;
        latex.push("    \\begin{tasks}(" + cols + ")");
        activity.questions.forEach((question, i) => {
            const questionLaTeX = markdownToLatex(question.formulation);
            const length = lengths[i];
            let decorator = " ";
            if (length >= 30) {
                decorator = "! ";
            }
            latex.push("      \\task" + decorator + questionLaTeX);
        });
        latex.push("    \\end{tasks}");
    }
    return latex;
}
function renderActivityAnswer(activity, opts) {
    const latex = [];
    if (!opts.keysPlacement) {
        latex.push("    \\item ");
    }
    latex.push("    \\begin{tasks}(2)");
    // Skip activity with no questions
    activity.questions.forEach((question, i) => {
        if (Math.abs(opts.includeKeys) === 1) {
            if (i === 0) {
                if (opts.includeKeys === -1) {
                    latex.push("      \\task " + (markdownToLatex(question.steps || question.answer)) || wsExporter_1.i18n("NO_ANSWER", opts.lang));
                }
                else {
                    latex.push("      \\task " + (markdownToLatex(question.answer)) || wsExporter_1.i18n("NO_ANSWER", opts.lang));
                }
            }
        }
        else {
            if (opts.includeKeys === -2) {
                latex.push("      \\task " + (markdownToLatex(question.steps || question.answer)) || wsExporter_1.i18n("NO_ANSWER", opts.lang));
            }
            else {
                latex.push("      \\task " + (markdownToLatex(question.answer)) || wsExporter_1.i18n("NO_ANSWER", opts.lang));
            }
        }
    });
    latex.push("    \\end{tasks}");
    return latex;
}
function markdownToLatex(str) {
    if (!str) {
        return str;
    }
    //Parse tree into latex format
    const tree = md.parse(str, {});
    return str;
}
function filterLatex(mdw) {
    mdw = mdw.replace(/’/g, "'").replace(/€/g, "\\euro{} ").
        replace(/’/g, "'").replace(/€/g, "\\euro{} ")
        .replace(/_/gmi, "\\_");
    return mdw;
}
//# sourceMappingURL=wsExporterLatex.js.map