import { AbstractDocumentTree, ActivityTree } from "../interfaces/AbstractDocumentTree";
import { i18n } from "./wsExporter";
import * as MarkdownIt from "markdown-it";
import * as attrs from "markdown-it-attrs";
import { latexRenderer } from "../util/latexRenderer";
import { gnp2Img } from "../dynimg/gnp2Img";

const md = new MarkdownIt();
md.use(attrs);

const PREAMBLE = `
\\documentclass[a4paper]{article}
\\usepackage{pgfplots}
\\pgfplotsset{compat=newest}
\\usepackage{geometry}
\\geometry{a4paper, total={170mm,257mm}, left=20mm, top=20mm}
\\usepackage{tasks} 
\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{enumitem}
\\usepackage{amsmath,amssymb}
\\usepackage{eurosym}
\\usepackage{xcolor}
\\usepackage{cancel}
\\usepackage{hyperref}
\\usepackage{csquotes}
\\usepackage[pdflatex]{graphicx}
\\definecolor{BLAUCLAR}{RGB}{240,240,255}
\\definecolor{MORAT}{RGB}{240,230,255}
\\definecolor{light-gray}{RGB}{244,246,249}
\\renewcommand{\\thesection}{\\Roman{section}}
\\newcommand{\\hr}{\\noindent\\textcolor[RGB]{218,221,227}{\\rule{\\textwidth}{0.2pt}}}
\\newcommand{\\quadrecolor}[3]{\\fcolorbox{#1}{#2}{\\parbox{0.93\\textwidth}{#3}\\vspace{0.5cm}}}

`;

export async function wsExporterLatex(adt: AbstractDocumentTree, opts: any): Promise<string> {

    const builder = ["% Generated by wsMath on " + new Date() + " (c) J. Mulet (2018)", PREAMBLE];

    // start generating all the images for this document (preferred type pdf-base64)
    var promises = [];
    adt.graphics.forEach( (g) => {
        g.id = g.id
        if (g.engine==="gnuplot") {
            const p = gnp2Img(g.script, "pdf"+g.dimensions.join(","), true);
            p.then((base64) => g.base64 = (<string> base64).replace("data:pdf;base64,", "") );
            promises.push(p);
        } else if(g.engine==="tikz") {
            //tickz can be directly rendered in pdf, no need to convert to pdf
        }
    });
    try {
        await Promise.all(promises);
    } catch(Ex) {
        console.log(Ex);
    }
    // Ok now, all images PDF have been correctly generated 
    // Include them to the document (inline, however)

    builder.push("% define inline PDF images");
    adt.graphics.forEach((g) => {
        if (g.base64) {
            builder.push("\\begin{filecontents*}{\\"+g.id+"}");
            builder.push(g.base64);
            builder.push("\\end{filecontents*}");
        }
    });

    builder.push("\\begin{document}");

    builder.push("% write inline images to disc");
    adt.graphics.forEach((g) => {
        if (g.base64) {
            builder.push("\\immediate\\write18{base64 -d \\" + g.id +" > \\" + g.id + ".pdf}");        
        }
    });
    builder.push("%");

    if (adt.title) {
        builder.push("\\begin{center}\\large \\textbf{ \\color{blue} " + adt.title + "} \\end{center}\n\\vspace{0.5cm}\n");
    }
    if (adt.instructions) {
        builder.push("\\quadrecolor{blue}{BLAUCLAR}{" + adt.instructions + "}\n");
    }

    builder.push(`\n {\\small \\textbf{${i18n('REFERENCE', opts.lang)}}   ${adt.sid}  /  ${adt.seed} .} \\textbf{${i18n('NAME', opts.lang)}:}  
        ${adt.fullname ? adt.fullname : ''}  \\dotfill`);


    if (adt.activities) {
        builder.push("\\begin{enumerate}");
        adt.activities.forEach((activity) => {
            builder.push(...renderActivity(adt, activity, opts));
        });
        builder.push("\\end{enumerate}");
    }
 
    if (adt.sections) {
        adt.sections.forEach((section) => {
            builder.push("  \\section{" + section.title + "}");
            builder.push("      \\begin{enumerate}[resume]");
            section.activities.forEach( (activity) => {
                builder.push(...renderActivity(adt, activity, opts));
            });
            builder.push("     \\end{enumerate}\n");            
        }); 
    }

    if (opts.includeKeys !== 0 && !opts.keysPlacement) {
        builder.push(`  \\section*{${i18n('ANSWERS', opts.lang)}}`);
        builder.push("  \\begin{enumerate}");
        if (adt.activities) {
            adt.activities.forEach( activity => {
                if (activity.questions.length) {
                    builder.push(...renderActivityAnswer(adt, activity, opts))
                }
            });
        }
        if (adt.sections) {
            adt.sections.forEach((section) => {
                section.activities.forEach(activity => {
                    if (activity.questions.length) {
                        builder.push(...renderActivityAnswer(adt, activity, opts));
                    }
                });     
            });
        }        
        builder.push("  \\end{enumerate}");
    } 

    builder.push("\\end{document}\n");

    return filterLatex(builder.join("\n"));    
}


function removeLaTeXCmds(cmd: string): string {
    const filtered = (cmd || "").replace(/\s/g,"").replace(/\\/gm, "").replace(/\{/gm, "").replace(/\}/gm, "")
                      .replace(/dfrac/gmi,"").replace(/frac/gmi,"").replace(/sqrt/gmi,"").replace(/cdot/gmi, ".")
                      .replace(/beginarray/gmi," ").replace(/endarray/gmi," ")
                      .replace(/left/gmi,"").replace(/right/gmi,"")
                      .replace(/\^/gmi,"").replace(/\_/gmi,"");
     return filtered;
}



function renderActivity(adt: AbstractDocumentTree, activity: ActivityTree, opts: any): string[] {
    const latex = [];
    activity.formulation = markdownToLatex(adt, activity.formulation);

    if (activity.questions.length === 0) {
        // Assume that this is a theory box
        latex.push("\\par \\quadrecolor{purple}{MORAT}{" + activity.formulation  + "} \n\n");

    } else if (activity.questions.length === 1) {
        activity.questions.forEach((question) => {
            latex.push("    \n\\item " + activity.formulation + markdownToLatex(adt, question.formulation));
        });           
    } else { 
        latex.push("    \n\\item " + activity.formulation);

        // Try to guess the number of columns
        const lengths = activity.questions.map(question => removeLaTeXCmds(question.formulation).length);
        const maxLength = Math.max(...lengths);
        const cols = maxLength < 26? 2 : 1;

        latex.push("    \\begin{tasks}(" + cols + ")");
        activity.questions.forEach((question, i) => {
            const questionLaTeX = markdownToLatex(adt, question.formulation);
            const length = lengths[i];
            let decorator = " ";
            if (length >= 30) {
                decorator="! ";
            }
            latex.push("      \\task" + decorator + questionLaTeX);           
        });
        latex.push("    \\end{tasks}");
    }
    return latex;
}


function renderActivityAnswer(adt: AbstractDocumentTree, activity: ActivityTree, opts: any): string[] {
    const latex = [];
    if (!opts.keysPlacement) {
        latex.push("    \n\\item ");
    }
    let startLi = "";
    if (activity.questions.length > 1) {
        latex.push("    \\begin{tasks}(2)");
        startLi = "      \\task ";
    }
    // Skip activity with no questions
    activity.questions.forEach((question, i) => {
        if (Math.abs(opts.includeKeys)===1) {
            if (i === 0 ) {
                if (opts.includeKeys === -1) {
                    latex.push(startLi + (markdownToLatex(adt, question.steps || question.answer) || i18n("NO_ANSWER", opts.lang)) );
                } else {
                    latex.push(startLi +  (markdownToLatex(adt, question.answer) || i18n("NO_ANSWER", opts.lang)) );
                }
            }
        } else {
            if (opts.includeKeys===-2) {
                latex.push(startLi +  (markdownToLatex(adt, question.steps || question.answer) || i18n("NO_ANSWER", opts.lang)) );
            } else {
                latex.push(startLi +  (markdownToLatex(adt, question.answer) || i18n("NO_ANSWER", opts.lang)) );
            }
        }
    });
    if (activity.questions.length > 1) {
        latex.push("    \\end{tasks}");
    }

    return latex;
}


function markdownToLatex(adt: AbstractDocumentTree, str: string): string {
    if (!str) {
        return str;
    }
    //Parse tree into latex format
    //The file text parser inline sets \ as end char so it removes it from text token
    str = str.replace(/\\\\\s/gm, "\\\\\\ ").replace(/\\\,/gm, "\\\\,").replace(/\\\;/gm, "\\\\;").replace(/\\{/gm, "\\\\{").replace(/\\\[/gm, "\\\\\\[");       
    let tree = md.parse(str, {});     
    return latexRenderer(adt, tree);
}

function filterLatex(mdw: string): string {

    mdw = mdw.replace(/’/g, "'").replace(/€/g, "\\euro{} ").
        replace(/’/g, "'").replace(/€/g, "\\euro{} ");

    return mdw;
}
